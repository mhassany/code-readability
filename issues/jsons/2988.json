{
    "url": "https://api.github.com/repos/pallets/flask/issues/2988",
    "repository_url": "https://api.github.com/repos/pallets/flask",
    "labels_url": "https://api.github.com/repos/pallets/flask/issues/2988/labels{/name}",
    "comments_url": "https://api.github.com/repos/pallets/flask/issues/2988/comments",
    "events_url": "https://api.github.com/repos/pallets/flask/issues/2988/events",
    "html_url": "https://github.com/pallets/flask/issues/2988",
    "id": 377088893,
    "node_id": "MDU6SXNzdWUzNzcwODg4OTM=",
    "number": 2988,
    "title": "Relationship error",
    "user": {
        "login": "Tryptich",
        "id": 14034311,
        "node_id": "MDQ6VXNlcjE0MDM0MzEx",
        "avatar_url": "https://avatars2.githubusercontent.com/u/14034311?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Tryptich",
        "html_url": "https://github.com/Tryptich",
        "followers_url": "https://api.github.com/users/Tryptich/followers",
        "following_url": "https://api.github.com/users/Tryptich/following{/other_user}",
        "gists_url": "https://api.github.com/users/Tryptich/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Tryptich/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Tryptich/subscriptions",
        "organizations_url": "https://api.github.com/users/Tryptich/orgs",
        "repos_url": "https://api.github.com/users/Tryptich/repos",
        "events_url": "https://api.github.com/users/Tryptich/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Tryptich/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2018-11-03T20:10:24Z",
    "updated_at": "2018-11-03T20:12:23Z",
    "closed_at": "2018-11-03T20:12:23Z",
    "author_association": "NONE",
    "body": "Hi, I have two classes with one-to-many relation type between them. when I want to retrieve one element on the parent objet, I get the error:\r\nrelationship 'recipes' expects a class or a mapper argument (received: <class 'sqlalchemy.sql.schema.Table'>)\r\n\r\nthis is my classes ;\r\nparent : \r\n\r\n```python\r\nclass UserJsonSerializer(JsonSerializer):\r\n    __json_public__ = ['id', 'email']\r\n\r\n\r\nclass User(UserJsonSerializer, db.Model):\r\n    __tablename__ = 'users'\r\n\r\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\r\n    public_id = db.Column(db.String(36),  primary_key=True,\r\n                          default=str(uuid.uuid4()))\r\n    username = db.Column(db.String(255))\r\n    email = db.Column(db.String(255), unique=True)\r\n    password_hash = db.Column(db.String(128))\r\n    _avatar_url = db.Column(db.String(260), nullable=True)\r\n    reputation = db.Column(db.Integer, default=0)\r\n    email_confirmation_sent_on = db.Column(\r\n        db.DateTime,  default=datetime.datetime.utcnow)\r\n    email_confirmed = db.Column(db.Boolean, nullable=True, default=False)\r\n    email_confirmed_on = db.Column(\r\n        db.DateTime, default=datetime.datetime.utcnow)\r\n    registered_on = db.Column(db.DateTime, default=datetime.datetime.utcnow)\r\n    last_login_at = db.Column(db.DateTime())\r\n    current_login_at = db.Column(db.DateTime())\r\n    last_login_ip = db.Column(db.String(100))\r\n    current_login_ip = db.Column(db.String(100))\r\n    login_count = db.Column(db.Integer)\r\n    roles = db.relationship('Role', secondary=roles_users,\r\n                            backref=db.backref('users', lazy='dynamic'))\r\n    recipes = db.relationship('Recipe', backref='user', lazy='dynamic')\r\n\r\n    @property\r\n    def password(self):\r\n        raise AttributeError('password: write-only field')\r\n\r\n    @password.setter\r\n    def password(self, password):\r\n        self.password_hash = bcrypt.generate_password_hash(\r\n            password).decode('utf-8')\r\n\r\n    def check_password(self, password):\r\n        return bcrypt.check_password_hash(self.password_hash, password)\r\n\r\n    @property\r\n    def avatar_url(self):\r\n        if not self._avatar_url:\r\n            return None\r\n        if self._avatar_url.startswith('http'):\r\n            return self._avatar_url\r\n        base = current_app.config['ZERQU_AVATAR_BASE']\r\n        return '%s%s' % (base, self._avatar_url)\r\nchild : \r\nclass Recipe(db.Model):\r\n    \"\"\"Recipe fields to add:\r\n        date last modified\r\n    \"\"\"\r\n    __tablename__ = \"Recipes\"\r\n\r\n    id = db.Column(db.Integer, autoincrement=True, primary_key=True)\r\n    public_id = db.Column(db.String(100), unique=True,\r\n                          default=str(uuid.uuid4()))\r\n    recipe_title = db.Column(db.String, nullable=True)\r\n    recipe_description = db.Column(db.String, nullable=True)\r\n    is_public = db.Column(db.Boolean, nullable=True)\r\n    image_filename = db.Column(db.String, default=None, nullable=True)\r\n    image_url = db.Column(db.String, default=None, nullable=True)\r\n    recipe_type = db.Column(db.String, default=None,\r\n                            nullable=True)  # TODO:recipe type update\r\n    rating = db.Column(db.Integer, default=None, nullable=True)\r\n    ingredients = db.Column(db.Text, default=None, nullable=True)\r\n    ingredients_html = db.Column(db.Text, default=None, nullable=True)\r\n    recipe_steps = db.Column(db.Text, default=None, nullable=True)\r\n    recipe_steps_html = db.Column(db.Text, default=None, nullable=True)\r\n    inspiration = db.Column(db.String, default=None, nullable=True)\r\n    dairy_free_recipe = db.Column(db.Boolean, nullable=True)\r\n    soy_free_recipe = db.Column(db.Boolean, nullable=True)\r\n    cholesterol_free_recipe = db.Column(db.Boolean, nullable=True)\r\n    created_on = db.Column(db.DateTime, nullable=False,\r\n                           default=datetime.datetime.utcnow)\r\n    updated_on = db.Column(db.DateTime, onupdate=datetime.datetime.utcnow)\r\n    created_by = db.Column(db.Integer, db.ForeignKey('users.id'))\r\n    category_id = db.Column(\r\n        db.Integer, db.ForeignKey('categories.id'))\r\n\r\nand this is the query: \r\n@staticmethod\r\n    def login_user(data):\r\n        try:\r\n            # fetch the user data\r\n            user = User.query.filter_by(email=data.get('email')).first() <-- this is the query\r\n            if user and user.check_password(data.get('password')):\r\n                auth_token = user.encode_auth_token(user.id)\r\n                if auth_token:\r\n                    response_object = {\r\n                        'status': 'success',\r\n                        'message': 'Successfully logged in.',\r\n                        'Authorization': auth_token.decode()\r\n                    }\r\n                    return response_object, 200\r\n            else:\r\n                response_object = {\r\n                    'status': 'fail',\r\n                    'message': 'email or password does not match.'\r\n                }\r\n                return response_object, 401\r\n\r\n        except Exception as e:\r\n            print(e)\r\n            response_object = {\r\n                'status': 'fail',\r\n                'message': 'Try again'\r\n            }\r\n            return response_object, 500\r\n```\r\n\r\n### Environment\r\n\r\n* Python version: 3.7.0\r\n* Flask version: 0.12.2\r\n* Werkzeug version:\r\n",
    "comments_inline": [
        {
            "url": "https://api.github.com/repos/pallets/flask/issues/comments/435617394",
            "html_url": "https://github.com/pallets/flask/issues/2988#issuecomment-435617394",
            "issue_url": "https://api.github.com/repos/pallets/flask/issues/2988",
            "id": 435617394,
            "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTYxNzM5NA==",
            "user": {
                "login": "ThiefMaster",
                "id": 179599,
                "node_id": "MDQ6VXNlcjE3OTU5OQ==",
                "avatar_url": "https://avatars1.githubusercontent.com/u/179599?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/ThiefMaster",
                "html_url": "https://github.com/ThiefMaster",
                "followers_url": "https://api.github.com/users/ThiefMaster/followers",
                "following_url": "https://api.github.com/users/ThiefMaster/following{/other_user}",
                "gists_url": "https://api.github.com/users/ThiefMaster/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/ThiefMaster/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ThiefMaster/subscriptions",
                "organizations_url": "https://api.github.com/users/ThiefMaster/orgs",
                "repos_url": "https://api.github.com/users/ThiefMaster/repos",
                "events_url": "https://api.github.com/users/ThiefMaster/events{/privacy}",
                "received_events_url": "https://api.github.com/users/ThiefMaster/received_events",
                "type": "User",
                "site_admin": false
            },
            "created_at": "2018-11-03T20:12:23Z",
            "updated_at": "2018-11-03T20:12:23Z",
            "author_association": "MEMBER",
            "body": "Please ask this in a place about SQLAlchemy (Stack Overflow, the sqlalchemy mailing list, or IRC). \r\n\r\nPS: Don't use `lazy='dynamic'`, usually you don't need/want that."
        }
    ]
}