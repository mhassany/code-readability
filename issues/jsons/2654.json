{
    "url": "https://api.github.com/repos/pallets/flask/issues/2654",
    "repository_url": "https://api.github.com/repos/pallets/flask",
    "labels_url": "https://api.github.com/repos/pallets/flask/issues/2654/labels{/name}",
    "comments_url": "https://api.github.com/repos/pallets/flask/issues/2654/comments",
    "events_url": "https://api.github.com/repos/pallets/flask/issues/2654/events",
    "html_url": "https://github.com/pallets/flask/issues/2654",
    "id": 303267515,
    "node_id": "MDU6SXNzdWUzMDMyNjc1MTU=",
    "number": 2654,
    "title": "Use of multiprocessing in before_first_request causes first request to hang, subsequent requests succeed, only under uwsgi, not standalone",
    "user": {
        "login": "dlparker",
        "id": 660124,
        "node_id": "MDQ6VXNlcjY2MDEyNA==",
        "avatar_url": "https://avatars1.githubusercontent.com/u/660124?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dlparker",
        "html_url": "https://github.com/dlparker",
        "followers_url": "https://api.github.com/users/dlparker/followers",
        "following_url": "https://api.github.com/users/dlparker/following{/other_user}",
        "gists_url": "https://api.github.com/users/dlparker/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/dlparker/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/dlparker/subscriptions",
        "organizations_url": "https://api.github.com/users/dlparker/orgs",
        "repos_url": "https://api.github.com/users/dlparker/repos",
        "events_url": "https://api.github.com/users/dlparker/events{/privacy}",
        "received_events_url": "https://api.github.com/users/dlparker/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2018-03-07T21:33:15Z",
    "updated_at": "2018-06-25T08:22:10Z",
    "closed_at": "2018-03-08T14:02:23Z",
    "author_association": "NONE",
    "body": "### Environment\r\n\r\n* Python version: 3.6.3\r\n* Flask version: 0.12.2\r\n* Werkzeug version: 0.14.1\r\n* UWSGI version: 2.0.17\r\n* Host: Raspberry Pi 3 running Raspbian stretch\r\n* Nginx version: 1.10.3\r\n\r\nIf a function starts a subprocess and uses queues to coordinate with it, and the function is run from @app.before_first_request, the first request hangs. This only happens under uwsgi, and only the first request hangs, everything is fine after that. \r\n\r\nI can work around this problem by starting the subprocess from a separate thread. I can also work around the process by having the subprocess exit quickly instead of hanging around waiting for more work. \r\n\r\nSince it works under Werkzeug, I realize that it may be a UWSGI bug, but I don't know how to diagnose it further. \r\n\r\nBelow is example code that does it. This was run on a Raspberry Pi (3) on stretch. \r\n\r\nNote that, using the more complex real code, which also uses Flask JSON RPC, attempting to browse the API with chrome timed out after a minute and reported ERR_INCOMPLETE_CHUNKED_ENCODING.\r\n\r\nTest it with:\r\n\r\n```curl -i http://your_host_here/ping```\r\n\r\nand it will hang. Kill that process, do it again, and you'll get a response.\r\n\r\nYou can change global variables in the code to switch the behavior to broken or either of the two work arounds (see comments in code).\r\n\r\nCode was run with this command:\r\n\r\n```\r\nsudo /usr/local/bin/uwsgi --ini /mypath/ts.ini --uid www-data --gid www-data  >& /dev/null &\r\n```\r\nand the ini file contents shown below the code.\r\n```\r\nimport sys\r\nimport os\r\nimport json\r\nimport time\r\nimport threading\r\nimport multiprocessing as mp\r\nimport queue as Queue\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__)\r\n# change this to True and it works\r\ndo_in_thread=False\r\n# or change this to True and it works\r\none_loop_only=False\r\n    \r\ndef worker(job_q, result_q):\r\n    go_command = job_q.get()\r\n    result_q.put_nowait(\"ok\")\r\n    while(True):\r\n        if not job_q.empty():\r\n            try:\r\n                message = job_q.get_nowait()\r\n                if message == None:\r\n                    result_q.put_nowait('gone')\r\n                    return\r\n                command = message.get('command', None)\r\n                if command is not None:\r\n                    if command == 'ping':\r\n                        result = \"pong\"\r\n                    else:\r\n                        result = \"error, invalid command {}\".format(command)\r\n                else:\r\n                    result = \"error invalid message, no command {}\".format(message)\r\n                result_q.put(result)\r\n            except Queue.Empty:\r\n                pass\r\n        time.sleep(0.1)\r\n\r\ndef cmd_init_thread():\r\n    job_queue = mp.Queue() # type: ignore\r\n    result_queue = mp.Queue() # type: ignore\r\n    p = mp.Process(target=worker, args=(job_queue, result_queue)) # type: ignore\r\n    job_queue.put(dict(command=\"go\"))\r\n    p.start()\r\n    start_res = result_queue.get()\r\n    if start_res != 'ok':\r\n        job_queue.put(None)\r\n        raise Exception('got {}'.format(start_res))\r\n    if one_loop_only:\r\n        job_queue.put(None)\r\n        return\r\n    job_queue.put(dict(command=\"ping\"))\r\n    pong_res = result_queue.get()\r\n    if pong_res != 'pong':\r\n        job_queue.put(None)\r\n        raise Exception('got {}'.format(pong_res))\r\n\r\n@app.before_first_request\r\ndef cmd_init():\r\n    if do_in_thread:\r\n        thread = threading.Thread(target=cmd_init_thread, daemon=True)\r\n        thread.start()\r\n    else:\r\n        cmd_init_thread()\r\n        \r\n@app.route('/ping', methods=['GET'])\r\ndef ping():\r\n    return json.dumps({\"pong\": True})\r\n\r\ndef startup(host=\"0.0.0.0\", port=5001):\r\n    cmd_init()\r\n    try:\r\n        app.run(host=host, port=port)\r\n    except RuntimeError:\r\n        sys.exit(1)\r\n\r\nif __name__ == \"__main__\":\r\n    startup()\r\n```\r\n\r\n```\r\n[uwsgi]\r\nchdir = /mypath\r\nmodule = ts\r\ncallable = app\r\n\r\nmaster = true\r\nprocesses = 1\r\nthreads = 2\r\n\r\nuid = www-data\r\ngid = www-data\r\nsocket = /tmp/my.sock\r\nchmod-socket = 664\r\nvacuum = true\r\n\r\ndie-on-term = true\r\nreq-logger = file:/mypath/req.log\r\nlogger = file:/mypath/error.log\r\n\r\n```\r\n\r\n",
    "comments_inline": [
        {
            "url": "https://api.github.com/repos/pallets/flask/issues/comments/371494976",
            "html_url": "https://github.com/pallets/flask/issues/2654#issuecomment-371494976",
            "issue_url": "https://api.github.com/repos/pallets/flask/issues/2654",
            "id": 371494976,
            "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTQ5NDk3Ng==",
            "user": {
                "login": "davidism",
                "id": 1242887,
                "node_id": "MDQ6VXNlcjEyNDI4ODc=",
                "avatar_url": "https://avatars1.githubusercontent.com/u/1242887?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/davidism",
                "html_url": "https://github.com/davidism",
                "followers_url": "https://api.github.com/users/davidism/followers",
                "following_url": "https://api.github.com/users/davidism/following{/other_user}",
                "gists_url": "https://api.github.com/users/davidism/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/davidism/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/davidism/subscriptions",
                "organizations_url": "https://api.github.com/users/davidism/orgs",
                "repos_url": "https://api.github.com/users/davidism/repos",
                "events_url": "https://api.github.com/users/davidism/events{/privacy}",
                "received_events_url": "https://api.github.com/users/davidism/received_events",
                "type": "User",
                "site_admin": false
            },
            "created_at": "2018-03-08T14:02:23Z",
            "updated_at": "2018-03-08T14:02:23Z",
            "author_association": "MEMBER",
            "body": "Does not appear to be an issue with Flask.\r\n\r\nPlease use Stack Overflow for questions about your own code. This tracker is for issues related to the project itself. Be sure to include a [minimal, complete, and verifiable example](https://stackoverflow.com/help/mcve)."
        },
        {
            "url": "https://api.github.com/repos/pallets/flask/issues/comments/371646350",
            "html_url": "https://github.com/pallets/flask/issues/2654#issuecomment-371646350",
            "issue_url": "https://api.github.com/repos/pallets/flask/issues/2654",
            "id": 371646350,
            "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTY0NjM1MA==",
            "user": {
                "login": "dlparker",
                "id": 660124,
                "node_id": "MDQ6VXNlcjY2MDEyNA==",
                "avatar_url": "https://avatars1.githubusercontent.com/u/660124?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/dlparker",
                "html_url": "https://github.com/dlparker",
                "followers_url": "https://api.github.com/users/dlparker/followers",
                "following_url": "https://api.github.com/users/dlparker/following{/other_user}",
                "gists_url": "https://api.github.com/users/dlparker/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/dlparker/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dlparker/subscriptions",
                "organizations_url": "https://api.github.com/users/dlparker/orgs",
                "repos_url": "https://api.github.com/users/dlparker/repos",
                "events_url": "https://api.github.com/users/dlparker/events{/privacy}",
                "received_events_url": "https://api.github.com/users/dlparker/received_events",
                "type": "User",
                "site_admin": false
            },
            "created_at": "2018-03-08T22:27:28Z",
            "updated_at": "2018-03-08T22:28:23Z",
            "author_association": "NONE",
            "body": "This may be an issue with uwsgi, and it may be an issue with Flask, and it might be a bug in some socket handling library, and it may be a problem with Python multiprocessing, but it is not an issue with my code. Running the example below will show that.\r\n\r\n If you tell me that it likely either library code or uwsgi problems, fine, I'll try to report it to the respective owners, but if you say it is a problem with my code then I don't think you've understood the report.\r\n\r\nTo repeat what I originally reported, my code causes no problems when run via app.run(), only when run under uwsgi.\r\n\r\nI have simplified the example code further, to remove to features I added because I thought they served to show that all the processes were behaving properly. This example will meet the minimal requirement literally instead of just in spirit. This code executes the same way in either case (uwsgi and standalone), and exits the init function in question (where the multiprocessing features are used) before the request is completed in either case. Also, additional tracing shows that the request function returns the expected 14 bytes in the hanging case just as in the working case.\r\n\r\nIn this example I removed the use of queues (which were for proof that everything executed properly) \r\nfrom the init function and instead just starts a subprocess.\r\n\r\nI also changed the code to call that init code during the first request directly from my request code to eliminate the before_first_request aspect of the original, although that is certainly how I'd want to run one time initialization.\r\n\r\nI have included the output from running under uwsgi below, and you can see that my code completes (both the init and the request) and then the uwsgi request logging shows that the expected 14 bytes are being produced. \r\n\r\nNew example:\r\n\r\n```\r\nimport json\r\nimport time\r\nimport threading\r\nimport multiprocessing as mp\r\nfrom flask import Flask\r\ninit_done = False\r\n\r\napp = Flask(__name__)\r\n\r\ndef worker():\r\n    while(True):\r\n        time.sleep(0.1)\r\n\r\ndef cmd_init_thread():\r\n    global init_done\r\n    if init_done:\r\n        return\r\n    p = mp.Process(target=worker)\r\n    p.start()\r\n    print('init done')\r\n    init_done = True\r\n\r\n@app.route('/ping', methods=['GET'])\r\ndef ping():\r\n    global init_done\r\n    if not init_done:\r\n        # comment this line and uncomment the thread ops and it works\r\n        cmd_init_thread()\r\n        #thread = threading.Thread(target=cmd_init_thread, daemon=True)\r\n        #thread.start()\r\n        print('calling init from ping')\r\n    return json.dumps({\"pong\": True})\r\n\r\nif __name__ == \"__main__\":\r\n    app.run()\r\n\r\n```\r\nSave it in a file called ts.py and run it like this and it works:\r\n\r\npython3.6 ts.py\r\n\r\nCall it like this:\r\n```\r\ncurl -i http://localhost:5000/ping\r\n```\r\n\r\noutput is \r\n```\r\nHTTP/1.0 200 OK\r\nContent-Type: text/html; charset=utf-8\r\nContent-Length: 14\r\nServer: Werkzeug/0.14.1 Python/3.6.3\r\nDate: Thu, 08 Mar 2018 21:25:07 GMT\r\n\r\n{\"pong\": true}\r\n```\r\n\r\nrun it like this (with nginx setup to proxy to it):\r\n\r\n```sudo /usr/local/bin/uwsgi  --uid www-data --gid www-data --module ts --callable app --socket /tmp/sigk_recorder_app.sock```\r\n\r\nand the same curl (with the proper address) will hang.\r\n\r\nHere is the output from uwsgi on that hung request you will see that my code completes and that the bytes count looks correct:\r\n\r\n```\r\n*** Starting uWSGI 2.0.17 (32bit) on [Thu Mar  8 15:26:45 2018] ***\r\ncompiled with version: 6.3.0 20170516 on 04 March 2018 21:38:59\r\nos: Linux-4.9.59-v7+ #1047 SMP Sun Oct 29 12:19:23 GMT 2017\r\nnodename: boathome\r\nmachine: armv7l\r\nclock source: unix\r\ndetected number of CPU cores: 4\r\ncurrent working directory: /opt/mystuff/panel1/server\r\ndetected binary path: /usr/local/bin/uwsgi\r\n!!! no internal routing support, rebuild with pcre support !!!\r\nsetgid() to 33\r\nsetuid() to 33\r\n*** WARNING: you are running uWSGI without its master process manager ***\r\nyour processes number limit is 7346\r\nyour memory page size is 4096 bytes\r\ndetected max file descriptor number: 1024\r\nlock engine: pthread robust mutexes\r\nthunder lock: disabled (you can enable it with --thunder-lock)\r\nuwsgi socket 0 bound to UNIX address /tmp/sigk_recorder_app.sock fd 3\r\nPython version: 3.6.3 (default, Jan  6 2018, 14:51:09)  [GCC 6.3.0 20170516]\r\n*** Python threads support is disabled. You can enable it with --enable-threads ***\r\nPython main interpreter initialized at 0x47f5c8\r\nyour server socket listen backlog is limited to 100 connections\r\nyour mercy for graceful operations on workers is 60 seconds\r\nmapped 64400 bytes (62 KB) for 1 cores\r\n*** Operational MODE: single process ***\r\nWSGI app 0 (mountpoint='') ready in 1 seconds on interpreter 0x47f5c8 pid: 32307 (default app)\r\n*** uWSGI is running in multiple interpreter mode ***\r\nspawned uWSGI worker 1 (and the only) (pid: 32307, cores: 1)\r\ncalling init from ping\r\ninit done\r\n[pid: 32307|app: 0|req: 1/1] 192.168.117.1 () {32 vars in 363 bytes} [Thu Mar  8 15:26:48 2018] GET /ping => generated 14 bytes in 15 msecs (HTTP/1.1 200) 2 headers in 79 bytes (1 switches on core 0)\r\n```"
        },
        {
            "url": "https://api.github.com/repos/pallets/flask/issues/comments/399867283",
            "html_url": "https://github.com/pallets/flask/issues/2654#issuecomment-399867283",
            "issue_url": "https://api.github.com/repos/pallets/flask/issues/2654",
            "id": 399867283,
            "node_id": "MDEyOklzc3VlQ29tbWVudDM5OTg2NzI4Mw==",
            "user": {
                "login": "alexvy86",
                "id": 716334,
                "node_id": "MDQ6VXNlcjcxNjMzNA==",
                "avatar_url": "https://avatars1.githubusercontent.com/u/716334?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/alexvy86",
                "html_url": "https://github.com/alexvy86",
                "followers_url": "https://api.github.com/users/alexvy86/followers",
                "following_url": "https://api.github.com/users/alexvy86/following{/other_user}",
                "gists_url": "https://api.github.com/users/alexvy86/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/alexvy86/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/alexvy86/subscriptions",
                "organizations_url": "https://api.github.com/users/alexvy86/orgs",
                "repos_url": "https://api.github.com/users/alexvy86/repos",
                "events_url": "https://api.github.com/users/alexvy86/events{/privacy}",
                "received_events_url": "https://api.github.com/users/alexvy86/received_events",
                "type": "User",
                "site_admin": false
            },
            "created_at": "2018-06-25T08:05:01Z",
            "updated_at": "2018-06-25T08:05:01Z",
            "author_association": "NONE",
            "body": "@dlparker did you ever figure this out? I think I'm running into a similar (maybe exactly the same) issue: when my application package loads for the first time, I start a background thread to listen for events coming from outside the application, but if I start that thread then *all* my web requests hang. I'm also using nginx as proxy to uwsgi, nginx logs each request as an error because \"upstream\" (uwsgi) didn't reply within the defined timeout, but I see absolutely no logs from uwsgi that it ever tried to process that request."
        },
        {
            "url": "https://api.github.com/repos/pallets/flask/issues/comments/399871605",
            "html_url": "https://github.com/pallets/flask/issues/2654#issuecomment-399871605",
            "issue_url": "https://api.github.com/repos/pallets/flask/issues/2654",
            "id": 399871605,
            "node_id": "MDEyOklzc3VlQ29tbWVudDM5OTg3MTYwNQ==",
            "user": {
                "login": "alexvy86",
                "id": 716334,
                "node_id": "MDQ6VXNlcjcxNjMzNA==",
                "avatar_url": "https://avatars1.githubusercontent.com/u/716334?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/alexvy86",
                "html_url": "https://github.com/alexvy86",
                "followers_url": "https://api.github.com/users/alexvy86/followers",
                "following_url": "https://api.github.com/users/alexvy86/following{/other_user}",
                "gists_url": "https://api.github.com/users/alexvy86/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/alexvy86/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/alexvy86/subscriptions",
                "organizations_url": "https://api.github.com/users/alexvy86/orgs",
                "repos_url": "https://api.github.com/users/alexvy86/repos",
                "events_url": "https://api.github.com/users/alexvy86/events{/privacy}",
                "received_events_url": "https://api.github.com/users/alexvy86/received_events",
                "type": "User",
                "site_admin": false
            },
            "created_at": "2018-06-25T08:22:10Z",
            "updated_at": "2018-06-25T08:22:10Z",
            "author_association": "NONE",
            "body": "Quick update: adding `--lazy-apps` when launching `uwsgi` seems to fix it for me... in my case the background thread establishes a connection to RabbitMQ so I could see that not playing nicely with being created once, before `fork`ing into the number of processes I specified (even if this is just 1).\r\n\r\nYour example seems much simpler... but maybe the `multiprocessing` library does something when it loads, that is \"not compatible\" with the default way uwsgi does things? (Preforking)."
        }
    ]
}