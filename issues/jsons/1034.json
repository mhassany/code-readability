{
    "url": "https://api.github.com/repos/pallets/flask/issues/1034",
    "repository_url": "https://api.github.com/repos/pallets/flask",
    "labels_url": "https://api.github.com/repos/pallets/flask/issues/1034/labels{/name}",
    "comments_url": "https://api.github.com/repos/pallets/flask/issues/1034/comments",
    "events_url": "https://api.github.com/repos/pallets/flask/issues/1034/events",
    "html_url": "https://github.com/pallets/flask/issues/1034",
    "id": 32267419,
    "node_id": "MDU6SXNzdWUzMjI2NzQxOQ==",
    "number": 1034,
    "title": "Add etag and last-modified helpers to improve cachability",
    "user": {
        "login": "fb",
        "id": 51237,
        "node_id": "MDQ6VXNlcjUxMjM3",
        "avatar_url": "https://avatars0.githubusercontent.com/u/51237?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fb",
        "html_url": "https://github.com/fb",
        "followers_url": "https://api.github.com/users/fb/followers",
        "following_url": "https://api.github.com/users/fb/following{/other_user}",
        "gists_url": "https://api.github.com/users/fb/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/fb/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/fb/subscriptions",
        "organizations_url": "https://api.github.com/users/fb/orgs",
        "repos_url": "https://api.github.com/users/fb/repos",
        "events_url": "https://api.github.com/users/fb/events{/privacy}",
        "received_events_url": "https://api.github.com/users/fb/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 5,
    "created_at": "2014-04-25T21:16:13Z",
    "updated_at": "2017-04-23T19:09:07Z",
    "closed_at": "2014-05-07T19:56:00Z",
    "author_association": "NONE",
    "body": "I noticed that there are no helpers for Etag or Last-Modified based caching.\n\nThat way we could use \n\n``` python\ndef json():\n    etag(some_etag)\n    last_modified(some_timestamp)\n\n    some_response = do_expensive_stuff\n    return some_response\n```\n\nwhich is _very_ useful when you implement an API with expensive operations which often get requests for the exactly same response. Add a caching proxy and and they are only expensive once. \n\n[Sinatra (Ruby)](https://github.com/sinatra/sinatra) has those helpers: https://github.com/sinatra/sinatra/blob/v1.4.5/lib/sinatra/base.rb#L439-L554\n",
    "comments_inline": [
        {
            "url": "https://api.github.com/repos/pallets/flask/issues/comments/42136804",
            "html_url": "https://github.com/pallets/flask/issues/1034#issuecomment-42136804",
            "issue_url": "https://api.github.com/repos/pallets/flask/issues/1034",
            "id": 42136804,
            "node_id": "MDEyOklzc3VlQ29tbWVudDQyMTM2ODA0",
            "user": {
                "login": "danielchatfield",
                "id": 1058676,
                "node_id": "MDQ6VXNlcjEwNTg2NzY=",
                "avatar_url": "https://avatars3.githubusercontent.com/u/1058676?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/danielchatfield",
                "html_url": "https://github.com/danielchatfield",
                "followers_url": "https://api.github.com/users/danielchatfield/followers",
                "following_url": "https://api.github.com/users/danielchatfield/following{/other_user}",
                "gists_url": "https://api.github.com/users/danielchatfield/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/danielchatfield/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/danielchatfield/subscriptions",
                "organizations_url": "https://api.github.com/users/danielchatfield/orgs",
                "repos_url": "https://api.github.com/users/danielchatfield/repos",
                "events_url": "https://api.github.com/users/danielchatfield/events{/privacy}",
                "received_events_url": "https://api.github.com/users/danielchatfield/received_events",
                "type": "User",
                "site_admin": false
            },
            "created_at": "2014-05-04T16:15:07Z",
            "updated_at": "2014-05-04T16:15:07Z",
            "author_association": "NONE",
            "body": "You can use `response.add_etag()` on a response object:\n\n``` python\ndef json():\n    some_response = do_expensive_stuff()\n    some_response = make_response(some_response)\n    some_response.add_etag()\n    return some_response\n```\n\nThis could quite easily be turned into a decorator.\n"
        },
        {
            "url": "https://api.github.com/repos/pallets/flask/issues/comments/42170655",
            "html_url": "https://github.com/pallets/flask/issues/1034#issuecomment-42170655",
            "issue_url": "https://api.github.com/repos/pallets/flask/issues/1034",
            "id": 42170655,
            "node_id": "MDEyOklzc3VlQ29tbWVudDQyMTcwNjU1",
            "user": {
                "login": "fb",
                "id": 51237,
                "node_id": "MDQ6VXNlcjUxMjM3",
                "avatar_url": "https://avatars0.githubusercontent.com/u/51237?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/fb",
                "html_url": "https://github.com/fb",
                "followers_url": "https://api.github.com/users/fb/followers",
                "following_url": "https://api.github.com/users/fb/following{/other_user}",
                "gists_url": "https://api.github.com/users/fb/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/fb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fb/subscriptions",
                "organizations_url": "https://api.github.com/users/fb/orgs",
                "repos_url": "https://api.github.com/users/fb/repos",
                "events_url": "https://api.github.com/users/fb/events{/privacy}",
                "received_events_url": "https://api.github.com/users/fb/received_events",
                "type": "User",
                "site_admin": false
            },
            "created_at": "2014-05-05T09:12:43Z",
            "updated_at": "2014-05-05T09:12:43Z",
            "author_association": "NONE",
            "body": "Maybe I did not make my point clear well enough. Surely, I know how to add a header to my response.\nI want my application to respond with 304 if Etag or Last-Modified match. I _don't_ want to regenerate any response which is already cached somewhere. `etag` or `last_modified` should yield a 304-response if the cache's object is fresh and otherwise add those headers to the newly response.\nThat's also how it's done in the code I linked.\n"
        },
        {
            "url": "https://api.github.com/repos/pallets/flask/issues/comments/42475244",
            "html_url": "https://github.com/pallets/flask/issues/1034#issuecomment-42475244",
            "issue_url": "https://api.github.com/repos/pallets/flask/issues/1034",
            "id": 42475244,
            "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDc1MjQ0",
            "user": {
                "login": "mitsuhiko",
                "id": 7396,
                "node_id": "MDQ6VXNlcjczOTY=",
                "avatar_url": "https://avatars1.githubusercontent.com/u/7396?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/mitsuhiko",
                "html_url": "https://github.com/mitsuhiko",
                "followers_url": "https://api.github.com/users/mitsuhiko/followers",
                "following_url": "https://api.github.com/users/mitsuhiko/following{/other_user}",
                "gists_url": "https://api.github.com/users/mitsuhiko/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/mitsuhiko/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mitsuhiko/subscriptions",
                "organizations_url": "https://api.github.com/users/mitsuhiko/orgs",
                "repos_url": "https://api.github.com/users/mitsuhiko/repos",
                "events_url": "https://api.github.com/users/mitsuhiko/events{/privacy}",
                "received_events_url": "https://api.github.com/users/mitsuhiko/received_events",
                "type": "User",
                "site_admin": false
            },
            "created_at": "2014-05-07T19:56:00Z",
            "updated_at": "2014-05-07T19:56:00Z",
            "author_association": "MEMBER",
            "body": "Not sure what exactly you are looking for.  There is already support for handling conditional requests.  http://werkzeug.pocoo.org/docs/wrappers/#werkzeug.wrappers.ETagResponseMixin.make_conditional\n"
        },
        {
            "url": "https://api.github.com/repos/pallets/flask/issues/comments/42479739",
            "html_url": "https://github.com/pallets/flask/issues/1034#issuecomment-42479739",
            "issue_url": "https://api.github.com/repos/pallets/flask/issues/1034",
            "id": 42479739,
            "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDc5NzM5",
            "user": {
                "login": "danielchatfield",
                "id": 1058676,
                "node_id": "MDQ6VXNlcjEwNTg2NzY=",
                "avatar_url": "https://avatars3.githubusercontent.com/u/1058676?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/danielchatfield",
                "html_url": "https://github.com/danielchatfield",
                "followers_url": "https://api.github.com/users/danielchatfield/followers",
                "following_url": "https://api.github.com/users/danielchatfield/following{/other_user}",
                "gists_url": "https://api.github.com/users/danielchatfield/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/danielchatfield/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/danielchatfield/subscriptions",
                "organizations_url": "https://api.github.com/users/danielchatfield/orgs",
                "repos_url": "https://api.github.com/users/danielchatfield/repos",
                "events_url": "https://api.github.com/users/danielchatfield/events{/privacy}",
                "received_events_url": "https://api.github.com/users/danielchatfield/received_events",
                "type": "User",
                "site_admin": false
            },
            "created_at": "2014-05-07T20:35:57Z",
            "updated_at": "2014-05-07T20:35:57Z",
            "author_association": "NONE",
            "body": "I think @fb is saying that if an e-tag has been set on the response and the request has an e-tag in it then flask should automatically return a not modified response.\n\nIn response to @fb:\n\n> I want my application to respond with 304 if Etag or Last-Modified match.\n\nAs per Armin's reply this can be done using:\n\n``` python\ndef json():\n    some_response = do_expensive_stuff()\n    some_response = make_response(some_response)\n    some_response.add_etag()\n    return some_response.make_conditional()\n```\n\n> I don't want to regenerate any response which is already cached somewhere. etag or last_modified should yield a 304-response if the cache's object is fresh and otherwise add those headers to the newly response.\n\nBut to add an e-tag you need to know what the response is, so either your etag is not reliant upon the response and thus isn't really an etag and can cause stale results to be used or it is reliant on the response and thus your goal of \"not wanting to regenerate a response\" won't be met. Supposing you can somehow generate the etag without actually generating the response then you could do something like this:\n\n``` python\ndef json()\n    some_response = make_response()\n    some_response.set_etag('the-etag')\n    some_response.make_conditional()\n    if some_response.status_code = 304:\n        return some_response\n    some_response =  do_expensive_stuff()\n    some_response.set_etag('the-etag')\n    return some_response\n```\n\nThese are very crude and I would make use of decorators but you get the rough idea\n"
        },
        {
            "url": "https://api.github.com/repos/pallets/flask/issues/comments/296480907",
            "html_url": "https://github.com/pallets/flask/issues/1034#issuecomment-296480907",
            "issue_url": "https://api.github.com/repos/pallets/flask/issues/1034",
            "id": 296480907,
            "node_id": "MDEyOklzc3VlQ29tbWVudDI5NjQ4MDkwNw==",
            "user": {
                "login": "reubano",
                "id": 157864,
                "node_id": "MDQ6VXNlcjE1Nzg2NA==",
                "avatar_url": "https://avatars1.githubusercontent.com/u/157864?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/reubano",
                "html_url": "https://github.com/reubano",
                "followers_url": "https://api.github.com/users/reubano/followers",
                "following_url": "https://api.github.com/users/reubano/following{/other_user}",
                "gists_url": "https://api.github.com/users/reubano/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/reubano/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/reubano/subscriptions",
                "organizations_url": "https://api.github.com/users/reubano/orgs",
                "repos_url": "https://api.github.com/users/reubano/repos",
                "events_url": "https://api.github.com/users/reubano/events{/privacy}",
                "received_events_url": "https://api.github.com/users/reubano/received_events",
                "type": "User",
                "site_admin": false
            },
            "created_at": "2017-04-23T19:09:07Z",
            "updated_at": "2017-04-23T19:09:07Z",
            "author_association": "NONE",
            "body": "What I did was use flask-cache to save the response and then created a `cache_header` decorator:\r\n\r\n```python\r\nfrom datetime import datetime as dt, timedelta\r\nfrom json import dumps\r\nfrom flask import make_response, request, route\r\nfrom app import cache\r\n\r\n\r\ndef jsonify(**kwargs):\r\n    response = make_response(dumps(kwargs))\r\n    response.headers['Content-Type'] = 'application/json; charset=utf-8'\r\n    response.headers['mimetype'] = 'application/json'\r\n    response.last_modified = dt.utcnow()\r\n    response.add_etag()\r\n    return response\r\n\r\n\r\ndef cache_header(max_age, **ckwargs):\r\n    def decorator(view):\r\n        f = cache.cached(max_age, **ckwargs)(view)\r\n\r\n        @wraps(f)\r\n        def wrapper(*args, **wkwargs):\r\n            response = f(*args, **wkwargs)\r\n            response.cache_control.max_age = max_age\r\n            response.cache_control.public = True\r\n            extra = timedelta(seconds=max_age)\r\n            response.expires = response.last_modified + extra\r\n            return response.make_conditional(request)\r\n        return wrapper\r\n\r\n    return decorator\r\n\r\n\r\n@route('/route')\r\n@cache_header(TIMEOUT)\r\ndef route():\r\n    result = do_expensive_stuff()\r\n    return jsonify(result=result)    \r\n```\r\n\r\nCR #637\r\n"
        }
    ]
}