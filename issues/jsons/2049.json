{
    "url": "https://api.github.com/repos/pallets/flask/issues/2049",
    "repository_url": "https://api.github.com/repos/pallets/flask",
    "labels_url": "https://api.github.com/repos/pallets/flask/issues/2049/labels{/name}",
    "comments_url": "https://api.github.com/repos/pallets/flask/issues/2049/comments",
    "events_url": "https://api.github.com/repos/pallets/flask/issues/2049/events",
    "html_url": "https://github.com/pallets/flask/issues/2049",
    "id": 181391530,
    "node_id": "MDU6SXNzdWUxODEzOTE1MzA=",
    "number": 2049,
    "title": "Cannot run many 'requests.post' against 'app.py'",
    "user": {
        "login": "jeff1evesque",
        "id": 2907085,
        "node_id": "MDQ6VXNlcjI5MDcwODU=",
        "avatar_url": "https://avatars0.githubusercontent.com/u/2907085?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jeff1evesque",
        "html_url": "https://github.com/jeff1evesque",
        "followers_url": "https://api.github.com/users/jeff1evesque/followers",
        "following_url": "https://api.github.com/users/jeff1evesque/following{/other_user}",
        "gists_url": "https://api.github.com/users/jeff1evesque/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/jeff1evesque/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/jeff1evesque/subscriptions",
        "organizations_url": "https://api.github.com/users/jeff1evesque/orgs",
        "repos_url": "https://api.github.com/users/jeff1evesque/repos",
        "events_url": "https://api.github.com/users/jeff1evesque/events{/privacy}",
        "received_events_url": "https://api.github.com/users/jeff1evesque/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2016-10-06T11:36:22Z",
    "updated_at": "2016-10-06T12:33:04Z",
    "closed_at": "2016-10-06T12:08:34Z",
    "author_association": "NONE",
    "body": "My application has automatic pytest on the travis ci, which implements `live_server`, so the app context only lives for the duration of the unit tests.  This contraption was devised using a series of docker containers.  Long story short, I didn't have time to replicate this automated process for my vagrant development environment.  So, I created some unit tests, which predicates on the following assumptions:\n- create self contain vagrant vm with [my application](https://github.com/jeff1evesque/machine-learning)\n  - download virtualbox with virtualbox guest\n  - download vagrant\n  - clone repository\n  - finally run `cd /path/to/clone/repository && vagrant up`\n- app context needs to be created by manually running `(cd /vagrant && python app.py &)`\n\nThen, the problems begin happening when I run a series of `requests.post` against the flask app.  I run such processes by triggering my manual pytests, which does a combination of `assert` against multiple `requests.post`.  So, in the same vagrant vm, I would run `(cd /vagrant/test && pytest manual)`.  This would run any python scripts prefixed with `pytest_*.py`, or `configure_.*.py`, in the [`manual/`](https://github.com/jeff1evesque/machine-learning/tree/master/test/manual) directory.\n\nWhen I run my manual unit tests one pass through, the [tests succeed](https://github.com/jeff1evesque/machine-learning/pull/2763#issuecomment-251582653), and as intended:\n\n``` bash\nvagrant@vagrant-ubuntu-trusty-64:/vagrant/test$ pytest manual\n========================================= test session starts ==========================================\nplatform linux2 -- Python 2.7.6, pytest-3.0.3, py-1.4.31, pluggy-0.4.0\nrootdir: /vagrant/test/manual, inifile: pytest.ini\nplugins: flask-0.10.0\ncollected 20 items\n\nmanual/configure_database.py .\nmanual/configure_redis.py .\nmanual/authentication/pytest_crypto.py .\nmanual/authentication/pytest_validate_password.py .\nmanual/programmatic_interface/dataset_url/pytest_svm_dataset_url.py ....\nmanual/programmatic_interface/dataset_url/pytest_svr_dataset_url.py ....\nmanual/programmatic_interface/file_upload/pytest_svm_file_upload.py ....\nmanual/programmatic_interface/file_upload/pytest_svr_file_upload.py ....\n\n====================================== 20 passed in 51.27 seconds ======================================\n```\n\nHowever, if I run the same tests again, without restarting flask, it breaks:\n\n``` bash\nvagrant@vagrant-ubuntu-trusty-64:/vagrant/test$ pytest manual\n========================================= test session starts ==========================================\nplatform linux2 -- Python 2.7.6, pytest-3.0.3, py-1.4.31, pluggy-0.4.0\nrootdir: /vagrant/test/manual, inifile: pytest.ini\nplugins: flask-0.10.0\ncollected 20 items\n\nmanual/configure_database.py .\nmanual/configure_redis.py .\nmanual/authentication/pytest_crypto.py .\nmanual/authentication/pytest_validate_password.py .\nmanual/programmatic_interface/dataset_url/pytest_svm_dataset_url.py ....\nmanual/programmatic_interface/dataset_url/pytest_svr_dataset_url.py ....\nmanual/programmatic_interface/file_upload/pytest_svm_file_upload.py ....\nmanual/programmatic_interface/file_upload/pytest_svr_file_upload.py [2016-10-05 01:11:23,116] ERROR in app: Exception on /load-data/ [POST]\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/flask/app.py\", line 1988, in wsgi_app\n  File \"/usr/local/lib/python2.7/dist-packages/flask/app.py\", line 1641, in full_dispatch_request\n  File \"/usr/local/lib/python2.7/dist-packages/flask/app.py\", line 1544, in handle_user_exception\n  File \"/usr/local/lib/python2.7/dist-packages/flask/app.py\", line 1639, in full_dispatch_request\n  File \"/usr/local/lib/python2.7/dist-packages/flask/app.py\", line 1625, in dispatch_request\n  File \"/vagrant/interface/views.py\", line 85, in load_data\n  File \"/vagrant/brain/load_data.py\", line 78, in load_data_new\n  File \"/vagrant/brain/session/base_data.py\", line 129, in save_premodel_dataset\n  File \"/vagrant/brain/session/data/save_dataset.py\", line 34, in dataset\n  File \"/vagrant/brain/database/save_feature.py\", line 86, in save_feature\n  File \"/vagrant/brain/database/db_query.py\", line 98, in sql_connect\nAttributeError: 'SQL' object has no attribute 'cursor'\nTraceback (most recent call last):\n  File \"app.py\", line 32, in <module>\n    app.run(host='0.0.0.0')\n  File \"/usr/local/lib/python2.7/dist-packages/flask/app.py\", line 843, in run\n    run_simple(host, port, self, **options)\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 694, in run_simple\n    inner()\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 659, in inner\n    srv.serve_forever()\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 499, in serve_forever\n    HTTPServer.serve_forever(self)\n  File \"/usr/lib/python2.7/SocketServer.py\", line 238, in serve_forever\n    self._handle_request_noblock()\n  File \"/usr/lib/python2.7/SocketServer.py\", line 297, in _handle_request_noblock\n    self.handle_error(request, client_address)\n  File \"/usr/lib/python2.7/SocketServer.py\", line 295, in _handle_request_noblock\n    self.process_request(request, client_address)\n  File \"/usr/lib/python2.7/SocketServer.py\", line 321, in process_request\n    self.finish_request(request, client_address)\n  File \"/usr/lib/python2.7/SocketServer.py\", line 334, in finish_request\n    self.RequestHandlerClass(request, client_address, self)\n  File \"/usr/lib/python2.7/SocketServer.py\", line 649, in __init__\n    self.handle()\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 216, in handle\n    rv = BaseHTTPRequestHandler.handle(self)\n  File \"/usr/lib/python2.7/BaseHTTPServer.py\", line 340, in handle\n    self.handle_one_request()\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 251, in handle_one_request\n    return self.run_wsgi()\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 193, in run_wsgi\n    execute(self.server.app)\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 181, in execute\n    application_iter = app(environ, start_response)\n  File \"/usr/local/lib/python2.7/dist-packages/flask/app.py\", line 2000, in __call__\n    return self.wsgi_app(environ, start_response)\n  File \"/usr/local/lib/python2.7/dist-packages/flask/app.py\", line 1991, in wsgi_app\n    response = self.make_response(self.handle_exception(e))\n  File \"/usr/local/lib/python2.7/dist-packages/flask/app.py\", line 1746, in make_response\n    rv = self.response_class.force_type(rv, request.environ)\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/wrappers.py\", line 847, in force_type\n    response = BaseResponse(*_run_wsgi_app(response, environ))\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/wrappers.py\", line 56, in _run_wsgi_app\n    from werkzeug.test import run_wsgi_app as _run_wsgi_app\nImportError: No module named test\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python2.7/dist-packages/apport_python_hook.py\", line 63, in apport_excepthook\n    from apport.fileutils import likely_packaged, get_recent_crashes\n  File \"/usr/lib/python2.7/dist-packages/apport/__init__.py\", line 5, in <module>\n    from apport.report import Report\nImportError: No module named report\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"app.py\", line 32, in <module>\n    app.run(host='0.0.0.0')\n  File \"/usr/local/lib/python2.7/dist-packages/flask/app.py\", line 843, in run\n    run_simple(host, port, self, **options)\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 694, in run_simple\n    inner()\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 659, in inner\n    srv.serve_forever()\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 499, in serve_forever\n    HTTPServer.serve_forever(self)\n  File \"/usr/lib/python2.7/SocketServer.py\", line 238, in serve_forever\n    self._handle_request_noblock()\n  File \"/usr/lib/python2.7/SocketServer.py\", line 297, in _handle_request_noblock\n    self.handle_error(request, client_address)\n  File \"/usr/lib/python2.7/SocketServer.py\", line 295, in _handle_request_noblock\n    self.process_request(request, client_address)\n  File \"/usr/lib/python2.7/SocketServer.py\", line 321, in process_request\n    self.finish_request(request, client_address)\n  File \"/usr/lib/python2.7/SocketServer.py\", line 334, in finish_request\n    self.RequestHandlerClass(request, client_address, self)\n  File \"/usr/lib/python2.7/SocketServer.py\", line 649, in __init__\n    self.handle()\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 216, in handle\n    rv = BaseHTTPRequestHandler.handle(self)\n  File \"/usr/lib/python2.7/BaseHTTPServer.py\", line 340, in handle\n    self.handle_one_request()\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 251, in handle_one_request\n    return self.run_wsgi()\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 193, in run_wsgi\n    execute(self.server.app)\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/serving.py\", line 181, in execute\n    application_iter = app(environ, start_response)\n  File \"/usr/local/lib/python2.7/dist-packages/flask/app.py\", line 2000, in __call__\n    return self.wsgi_app(environ, start_response)\n  File \"/usr/local/lib/python2.7/dist-packages/flask/app.py\", line 1991, in wsgi_app\n    response = self.make_response(self.handle_exception(e))\n  File \"/usr/local/lib/python2.7/dist-packages/flask/app.py\", line 1746, in make_response\n    rv = self.response_class.force_type(rv, request.environ)\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/wrappers.py\", line 847, in force_type\n    response = BaseResponse(*_run_wsgi_app(response, environ))\n  File \"/usr/local/lib/python2.7/dist-packages/werkzeug/wrappers.py\", line 56, in _run_wsgi_app\n    from werkzeug.test import run_wsgi_app as _run_wsgi_app\nImportError: No module named test\nFFFF\n\n=============================================== FAILURES ===============================================\n____________________________________________ test_data_new _____________________________________________\n\n    def test_data_new():\n        '''@test_data_new\n\n        This method tests the 'data_new' session.\n\n        '''\n\n>       assert requests.post(\n            endpoint_url,\n            headers=headers,\n            data=get_sample_json('svr-data-new.json', 'svr')\n        )\n\nmanual/programmatic_interface/file_upload/pytest_svr_file_upload.py:71:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n/usr/lib/python2.7/dist-packages/requests/api.py:88: in post\n    return request('post', url, data=data, **kwargs)\n/usr/lib/python2.7/dist-packages/requests/api.py:44: in request\n    return session.request(method=method, url=url, **kwargs)\n/usr/lib/python2.7/dist-packages/requests/sessions.py:455: in request\n    resp = self.send(prep, **send_kwargs)\n/usr/lib/python2.7/dist-packages/requests/sessions.py:558: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x7fe471358810>, request = <PreparedRequest [POST]>\nstream = False, timeout = <urllib3.util.Timeout object at 0x7fe4706dc0d0>, verify = True, cert = None\nproxies = OrderedDict()\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n\n            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n            :param stream: (optional) Whether to stream the request content.\n            :param timeout: (optional) The timeout on the request.\n            :param verify: (optional) Whether to verify SSL certificates.\n            :param cert: (optional) Any user-provided SSL certificate to be trusted.\n            :param proxies: (optional) The proxies dictionary to apply to the request.\n            \"\"\"\n\n        conn = self.get_connection(request.url, proxies)\n\n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request)\n\n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n\n        if stream:\n            timeout = TimeoutSauce(connect=timeout)\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n\n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n\n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n\n                low_conn = conn._get_conn(timeout=timeout)\n\n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n\n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n\n                    low_conn.endheaders()\n\n                    for i in request.body:\n                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\n                        low_conn.send(b'\\r\\n')\n                        low_conn.send(i)\n                        low_conn.send(b'\\r\\n')\n                    low_conn.send(b'0\\r\\n\\r\\n')\n\n                    r = low_conn.getresponse()\n                    resp = HTTPResponse.from_httplib(\n                        r,\n                        pool=conn,\n                        connection=low_conn,\n                        preload_content=False,\n                        decode_content=False\n                    )\n                except:\n                    # If we hit any problems here, clean up the connection.\n                    # Then, reraise so that we can handle the actual exception.\n                    low_conn.close()\n                    raise\n                else:\n                    # All is well, return the connection to the pool.\n                    conn._put_conn(low_conn)\n\n        except socket.error as sockerr:\n            raise ConnectionError(sockerr)\n\n        except MaxRetryError as e:\n>           raise ConnectionError(e)\nE           ConnectionError: HTTPConnectionPool(host='localhost', port=5000): Max retries exceeded with url: /load-data/ (Caused by <class 'httplib.BadStatusLine'>: '')\n\n/usr/lib/python2.7/dist-packages/requests/adapters.py:378: ConnectionError\n___________________________________________ test_data_append ___________________________________________\n\n    def test_data_append():\n        '''@test_data_append\n\n        This method tests the 'data_append' session.\n\n        '''\n\n>       assert requests.post(\n            endpoint_url,\n            headers=headers,\n            data=get_sample_json('svr-data-append.json', 'svr')\n        )\n\nmanual/programmatic_interface/file_upload/pytest_svr_file_upload.py:85:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n/usr/lib/python2.7/dist-packages/requests/api.py:88: in post\n    return request('post', url, data=data, **kwargs)\n/usr/lib/python2.7/dist-packages/requests/api.py:44: in request\n    return session.request(method=method, url=url, **kwargs)\n/usr/lib/python2.7/dist-packages/requests/sessions.py:455: in request\n    resp = self.send(prep, **send_kwargs)\n/usr/lib/python2.7/dist-packages/requests/sessions.py:558: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x7fe4706fa5d0>, request = <PreparedRequest [POST]>\nstream = False, timeout = <urllib3.util.Timeout object at 0x7fe4706fa8d0>, verify = True, cert = None\nproxies = OrderedDict()\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n\n            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n            :param stream: (optional) Whether to stream the request content.\n            :param timeout: (optional) The timeout on the request.\n            :param verify: (optional) Whether to verify SSL certificates.\n            :param cert: (optional) Any user-provided SSL certificate to be trusted.\n            :param proxies: (optional) The proxies dictionary to apply to the request.\n            \"\"\"\n\n        conn = self.get_connection(request.url, proxies)\n\n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request)\n\n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n\n        if stream:\n            timeout = TimeoutSauce(connect=timeout)\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n\n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n\n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n\n                low_conn = conn._get_conn(timeout=timeout)\n\n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n\n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n\n                    low_conn.endheaders()\n\n                    for i in request.body:\n                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\n                        low_conn.send(b'\\r\\n')\n                        low_conn.send(i)\n                        low_conn.send(b'\\r\\n')\n                    low_conn.send(b'0\\r\\n\\r\\n')\n\n                    r = low_conn.getresponse()\n                    resp = HTTPResponse.from_httplib(\n                        r,\n                        pool=conn,\n                        connection=low_conn,\n                        preload_content=False,\n                        decode_content=False\n                    )\n                except:\n                    # If we hit any problems here, clean up the connection.\n                    # Then, reraise so that we can handle the actual exception.\n                    low_conn.close()\n                    raise\n                else:\n                    # All is well, return the connection to the pool.\n                    conn._put_conn(low_conn)\n\n        except socket.error as sockerr:\n            raise ConnectionError(sockerr)\n\n        except MaxRetryError as e:\n>           raise ConnectionError(e)\nE           ConnectionError: HTTPConnectionPool(host='localhost', port=5000): Max retries exceeded with url: /load-data/ (Caused by <class 'socket.error'>: [Errno 111] Connection refused)\n\n/usr/lib/python2.7/dist-packages/requests/adapters.py:378: ConnectionError\n_________________________________________ test_model_generate __________________________________________\n\n    def test_model_generate():\n        '''@test_model_generate\n\n        This method tests the 'model_generate' session.\n\n        '''\n\n>       assert requests.post(\n            endpoint_url,\n            headers=headers,\n            data=get_sample_json('svr-model-generate.json', 'svr')\n        )\n\nmanual/programmatic_interface/file_upload/pytest_svr_file_upload.py:99:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n/usr/lib/python2.7/dist-packages/requests/api.py:88: in post\n    return request('post', url, data=data, **kwargs)\n/usr/lib/python2.7/dist-packages/requests/api.py:44: in request\n    return session.request(method=method, url=url, **kwargs)\n/usr/lib/python2.7/dist-packages/requests/sessions.py:455: in request\n    resp = self.send(prep, **send_kwargs)\n/usr/lib/python2.7/dist-packages/requests/sessions.py:558: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x7fe4706f1ed0>, request = <PreparedRequest [POST]>\nstream = False, timeout = <urllib3.util.Timeout object at 0x7fe4706939d0>, verify = True, cert = None\nproxies = OrderedDict()\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n\n            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n            :param stream: (optional) Whether to stream the request content.\n            :param timeout: (optional) The timeout on the request.\n            :param verify: (optional) Whether to verify SSL certificates.\n            :param cert: (optional) Any user-provided SSL certificate to be trusted.\n            :param proxies: (optional) The proxies dictionary to apply to the request.\n            \"\"\"\n\n        conn = self.get_connection(request.url, proxies)\n\n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request)\n\n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n\n        if stream:\n            timeout = TimeoutSauce(connect=timeout)\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n\n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n\n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n\n                low_conn = conn._get_conn(timeout=timeout)\n\n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n\n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n\n                    low_conn.endheaders()\n\n                    for i in request.body:\n                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\n                        low_conn.send(b'\\r\\n')\n                        low_conn.send(i)\n                        low_conn.send(b'\\r\\n')\n                    low_conn.send(b'0\\r\\n\\r\\n')\n\n                    r = low_conn.getresponse()\n                    resp = HTTPResponse.from_httplib(\n                        r,\n                        pool=conn,\n                        connection=low_conn,\n                        preload_content=False,\n                        decode_content=False\n                    )\n                except:\n                    # If we hit any problems here, clean up the connection.\n                    # Then, reraise so that we can handle the actual exception.\n                    low_conn.close()\n                    raise\n                else:\n                    # All is well, return the connection to the pool.\n                    conn._put_conn(low_conn)\n\n        except socket.error as sockerr:\n            raise ConnectionError(sockerr)\n\n        except MaxRetryError as e:\n>           raise ConnectionError(e)\nE           ConnectionError: HTTPConnectionPool(host='localhost', port=5000): Max retries exceeded with url: /load-data/ (Caused by <class 'socket.error'>: [Errno 111] Connection refused)\n\n/usr/lib/python2.7/dist-packages/requests/adapters.py:378: ConnectionError\n__________________________________________ test_model_predict __________________________________________\n\n    def test_model_predict():\n        '''@test_model_predict\n\n        This method tests the 'model_predict' session.\n\n        '''\n\n>       assert requests.post(\n            endpoint_url,\n            headers=headers,\n            data=get_sample_json('svr-model-predict.json', 'svr')\n        )\n\nmanual/programmatic_interface/file_upload/pytest_svr_file_upload.py:113:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n/usr/lib/python2.7/dist-packages/requests/api.py:88: in post\n    return request('post', url, data=data, **kwargs)\n/usr/lib/python2.7/dist-packages/requests/api.py:44: in request\n    return session.request(method=method, url=url, **kwargs)\n/usr/lib/python2.7/dist-packages/requests/sessions.py:455: in request\n    resp = self.send(prep, **send_kwargs)\n/usr/lib/python2.7/dist-packages/requests/sessions.py:558: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x7fe4706f3850>, request = <PreparedRequest [POST]>\nstream = False, timeout = <urllib3.util.Timeout object at 0x7fe4706f3410>, verify = True, cert = None\nproxies = OrderedDict()\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n\n            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n            :param stream: (optional) Whether to stream the request content.\n            :param timeout: (optional) The timeout on the request.\n            :param verify: (optional) Whether to verify SSL certificates.\n            :param cert: (optional) Any user-provided SSL certificate to be trusted.\n            :param proxies: (optional) The proxies dictionary to apply to the request.\n            \"\"\"\n\n        conn = self.get_connection(request.url, proxies)\n\n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request)\n\n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n\n        if stream:\n            timeout = TimeoutSauce(connect=timeout)\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n\n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n\n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n\n                low_conn = conn._get_conn(timeout=timeout)\n\n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n\n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n\n                    low_conn.endheaders()\n\n                    for i in request.body:\n                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\n                        low_conn.send(b'\\r\\n')\n                        low_conn.send(i)\n                        low_conn.send(b'\\r\\n')\n                    low_conn.send(b'0\\r\\n\\r\\n')\n\n                    r = low_conn.getresponse()\n                    resp = HTTPResponse.from_httplib(\n                        r,\n                        pool=conn,\n                        connection=low_conn,\n                        preload_content=False,\n                        decode_content=False\n                    )\n                except:\n                    # If we hit any problems here, clean up the connection.\n                    # Then, reraise so that we can handle the actual exception.\n                    low_conn.close()\n                    raise\n                else:\n                    # All is well, return the connection to the pool.\n                    conn._put_conn(low_conn)\n\n        except socket.error as sockerr:\n            raise ConnectionError(sockerr)\n\n        except MaxRetryError as e:\n>           raise ConnectionError(e)\nE           ConnectionError: HTTPConnectionPool(host='localhost', port=5000): Max retries exceeded with url: /load-data/ (Caused by <class 'socket.error'>: [Errno 111] Connection refused)\n\n/usr/lib/python2.7/dist-packages/requests/adapters.py:378: ConnectionError\n================================ 4 failed, 16 passed in 119.02 seconds =================================\n```\n\nWhen the flask errors, it also kills the `app.py` process, which I verified by running `netstat -ntlup`:\n\n``` bash\nvagrant@vagrant-ubuntu-trusty-64:/vagrant/test$ netstat -ntlup\n(No info could be read for \"-p\": geteuid()=1000 but you should be root.)\nActive Internet connections (only servers)\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN      -\ntcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN      -\ntcp        0      0 0.0.0.0:55019           0.0.0.0:*               LISTEN      -\ntcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      -\ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -\ntcp6       0      0 :::111                  :::*                    LISTEN      -\ntcp6       0      0 :::22                   :::*                    LISTEN      -\ntcp6       0      0 :::56952                :::*                    LISTEN      -\nudp        0      0 0.0.0.0:111             0.0.0.0:*                           -\nudp        0      0 0.0.0.0:40866           0.0.0.0:*                           -\nudp        0      0 0.0.0.0:679             0.0.0.0:*                           -\nudp        0      0 0.0.0.0:52672           0.0.0.0:*                           -\nudp        0      0 127.0.0.1:739           0.0.0.0:*                           -\nudp        0      0 0.0.0.0:68              0.0.0.0:*                           -\nudp6       0      0 :::111                  :::*                                -\nudp6       0      0 :::42109                :::*                                -\nudp6       0      0 :::679                  :::*                                -\nudp6       0      0 :::34032                :::*                                -\n```\n\n**Notice:** there is no process running on the default port `5000`.\n\nSo, I did some minor debugging, and found that my application never throttles [70.2% memory](https://github.com/jeff1evesque/machine-learning/pull/2763#issuecomment-251841492), of the `512MB` virtualbox virtual machine.  When the application finishes the series of `requests.post`, it returns to baseline measure:\n\n![top-2](https://cloud.githubusercontent.com/assets/2907085/19150519/46828792-8b95-11e6-88b7-ca074b2a6b6c.PNG)\n\n![top-3](https://cloud.githubusercontent.com/assets/2907085/19150527/4b82e782-8b95-11e6-8fa7-c4e8a79b3aed.PNG)\n\n**Note:** top is always updating the processes in the terminal output, which is why I pasted two screenshots.  Also, these screenshots are taken about 8 hours since I ran my last attempt of my manual unit tests, which killed `app.py`.  So, `app.py` is not currently running.\n\nI haven't configured uwsgi, or gunicorn.  I'm hoping if I configure gunicorn, it will create work processes, that can handle such `requests.post` against `app.py` more elegantly, to prevent `app.py` from exiting.   But, I'm not sure if my problem is an internal flask bug, given my use case.  Therefore, I'm not sure if gunicorn will solve my problem.\n\nThe [database user](https://github.com/jeff1evesque/machine-learning/blob/7a4989fc6d93a6df73027715dbbba16ae997776b/puppet/environment/docker/modules/database/manifests/server.pp#L28-L35) which runs the application, is allowed unlimited connections, and queries.  So, I don't know why my application stops running on the second iteration of the manual `pytest`'s.  Additionally, when my manual unit tests run, I make sure I empty the database tables, which will be operated on.  Since, [`configure_database.py`](https://github.com/jeff1evesque/machine-learning/blob/780d0cd1a6ca724e4db09c0bbceac522f03e2789/test/manual/configure_database.py#L43-L48) is the first file alphabetically closest to the start of the alphabet, it runs first.  So, the database is always refreshed on each iteration, and the [database user](https://github.com/jeff1evesque/machine-learning/blob/7a4989fc6d93a6df73027715dbbba16ae997776b/puppet/environment/docker/modules/database/manifests/server.pp#L44-L50) that performs the `TRUNCATE` operation on each of the database tables, has adequate permission.  I did have another idea, since I was getting errors related to database `cursor`.  Specifically, I thought that maybe my application was heavy on the database operations.  And, for the first time, I checked my database api [`db_query.py`](https://github.com/jeff1evesque/machine-learning/blob/c761a61d58e0444b1a325e81f62310f911c3f784/brain/database/db_query.py#L131), and realized that after each database transaction, including during connection, and disconnection, I write to a log file.  I think after running my manual unit tests, I checked in the corresponding text log file, and it was already 301MB.  This is just from writing to the logs for running the manual unit tests twice.  So, I commented out all instances of writing to a logfile, in `db_query.py`, the API for all of my database queries, and my errors still persists.\n",
    "comments_inline": [
        {
            "url": "https://api.github.com/repos/pallets/flask/issues/comments/251943202",
            "html_url": "https://github.com/pallets/flask/issues/2049#issuecomment-251943202",
            "issue_url": "https://api.github.com/repos/pallets/flask/issues/2049",
            "id": 251943202,
            "node_id": "MDEyOklzc3VlQ29tbWVudDI1MTk0MzIwMg==",
            "user": {
                "login": "untitaker",
                "id": 837573,
                "node_id": "MDQ6VXNlcjgzNzU3Mw==",
                "avatar_url": "https://avatars0.githubusercontent.com/u/837573?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/untitaker",
                "html_url": "https://github.com/untitaker",
                "followers_url": "https://api.github.com/users/untitaker/followers",
                "following_url": "https://api.github.com/users/untitaker/following{/other_user}",
                "gists_url": "https://api.github.com/users/untitaker/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/untitaker/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/untitaker/subscriptions",
                "organizations_url": "https://api.github.com/users/untitaker/orgs",
                "repos_url": "https://api.github.com/users/untitaker/repos",
                "events_url": "https://api.github.com/users/untitaker/events{/privacy}",
                "received_events_url": "https://api.github.com/users/untitaker/received_events",
                "type": "User",
                "site_admin": false
            },
            "created_at": "2016-10-06T12:08:33Z",
            "updated_at": "2016-10-06T12:08:33Z",
            "author_association": "MEMBER",
            "body": "Please ask questions on StackOverflow, if you have a bugreport prepare a minimal example.\n"
        }
    ]
}